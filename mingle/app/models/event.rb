#  Copyright 2020 ThoughtWorks, Inc.
#  
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as
#  published by the Free Software Foundation, either version 3 of the
#  License, or (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.
#  
#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/agpl-3.0.txt>.

class Event < ActiveRecord::Base
  include SqlHelper
  # mingle_timestamp column is used as our logical ordering column and it generated by column default using database
  # clock when we insert a record. So we should not let AR mess with it
  IGNORED_COLUMNS = %w(mingle_timestamp)

  has_many :changes, :dependent => :delete_all, :order => :id
  belongs_to :origin, :polymorphic => true
  belongs_to :deliverable, :foreign_type => 'deliverable_type'
  belongs_to :created_by, :class_name => '::User', :foreign_key => 'created_by_user_id'
  serialize :details
  #todo: remove without_correction scope after correction event story works
  named_scope :without_correction, :conditions => ["type != ?", "CorrectionEvent"]
  validates_uniqueness_of :origin_id, :scope => [:origin_type, :type, :deliverable_id], :if => lambda { |event|
    !(
      event.is_a?(CorrectionEvent) ||
      event.is_a?(CardCopyEvent::To) ||
      event.is_a?(LiveOnlyEvents::Base)
    )
  }

  def modified_by_user_login
    created_by.login
  end

  def card_related?
    origin.class.name == 'Card::Version'
  end

  class NonMingleAuthor < Struct.new(:name)
    def id
      nil
    end

    def resource_link(*args)
      nil
    end

    def email
      nil
    end

    def icon_path
      nil
    end
  end

  class << self
    def columns
      super.reject { |c| IGNORED_COLUMNS.include?(c.name) }
    end

    def deliverable_dependency_column
      'deliverable_id'
    end

    def with_project_scope(project_id, created_at, created_by_user_id)
      with_scope(:create => {:deliverable_id => project_id, :created_at => created_at, :created_by_user_id => created_by_user_id, :deliverable_type => Deliverable::DELIVERABLE_TYPE_PROJECT}) do
        yield
      end
    end

    def with_program_scope(program_id, created_at, created_by_user_id)
      with_scope(:create => {:deliverable_id => program_id, :created_at => created_at, :created_by_user_id => created_by_user_id, :deliverable_type => Deliverable::DELIVERABLE_TYPE_PROGRAM}) do
        yield
      end
    end

    def card_version(card_version)
      origin_type = Thread.current['origin_type']
      if (!origin_type.nil?)
        CardVersionEvent.create!(current_scoped_methods[:create].merge(:origin => card_version, :details => {:event_source => origin_type}))
      else
        CardVersionEvent.create!(current_scoped_methods[:create].merge(:origin => card_version))
      end
    end

    def card_deletion(card_version)
      CardDeletionEvent.create!(current_scoped_methods[:create].merge(:origin => card_version))
    end

    def page_version(page_version)
      PageVersionEvent.create!(current_scoped_methods[:create].merge(:origin => page_version))
    end

    def dependency_version(dependency_version)
      DependencyVersionEvent.create!(current_scoped_methods[:create].merge(:origin => dependency_version))
    end

    def dependency_deletion(dependency_version)
      DependencyDeletionEvent.create!(current_scoped_methods[:create].merge(:origin => dependency_version))
    end

    def page_deletion(page_version)
      PageDeletionEvent.create!(current_scoped_methods[:create].merge(:origin => page_version))
    end

    def revision(revision)
      RevisionEvent.create!(current_scoped_methods[:create].merge(:origin => revision))
    end

    def objective_version(objective_version)
      ObjectiveVersionEvent.create!(current_scoped_methods[:create].merge(:origin => objective_version))
    end

    def objective_deletion(objective_version)
      ObjectiveDeletionEvent.create!(current_scoped_methods[:create].merge(:origin => objective_version))
    end

    def card_copy(origin, associate, event_type)
      associate_project = Project.find(associate.project_id)

      details = {:associate_card_number => associate.number, :associate_project_identifier => associate_project.identifier}
      event_type.create!(current_scoped_methods[:create].merge(:origin => origin, :details => details))
    end

    def bulk_generate(version_model, event_type, project, updater_id=nil)
      raise "Events already exist, version_id_condition: #{version_id_condition}" if project.events_without_eager_loading.count(:conditions => ["origin_type = ? and type = ? and exists (select 1 from #{version_model.quoted_table_name} v where v.updater_id = '#{updater_id}' and v.id = origin_id)", version_model.name, event_type.name] ) > 0
      select_columns = [connection.quote(event_type.name), connection.quote(version_model.name), 'v.id', 'v.updated_at', 'v.modified_by_user_id', 'v.project_id']
      insert_columns = ['type', 'origin_type', 'origin_id', 'created_at', 'created_by_user_id', 'deliverable_id']

      if connection.prefetch_primary_key?(Event)
        select_columns.unshift(connection.next_id_sql(Event.table_name))
        insert_columns.unshift('id')
      end

      cond = updater_id.nil? ? "v.id IS NOT NULL" : "updater_id = '#{updater_id}'"
      insert_events_sql = "INSERT INTO #{Event.quoted_table_name} (#{insert_columns.join(',')})
                           SELECT #{select_columns.join(',')}
                             FROM #{version_model.quoted_table_name} v
                            WHERE project_id = #{project.id}
                              AND #{cond}"

      connection.execute(insert_events_sql)
    end
  end

  def details_still_loading?
    time_since_update = Clock.now - created_at
    # Using #to_a here (for caching purposes) because multiple changes.empty? calls make it all the way to DB. #5370.
    changes.to_a.empty? && time_since_update < loading_time_threshold
  end

  def changes_for_card_type(card_type)
    return changes if changes.size == 1
    property_definition_changes = card_type.property_definitions.inject([]) do |aggregation, property_definition|
      changes.each { |change| aggregation << change if change.from_property_definition?(property_definition) }
      aggregation
    end
    non_property_definition_changes = changes - property_definition_changes
    property_definition_changes + non_property_definition_changes
  end

  # optimization
  def project
    Project.current
  end

  def to_s
    if origin
      "#{self.class}[origin => #{origin}]"
    else
      "#{self.class}[origin => #{origin_type} #{origin_id} (unable to locate origin in DB)]"
    end
  end

  def self.lock_and_generate_changes!(event_id)
    transaction do
      # lock event, so that no other transaction could update this event including changes
      if event = Event.find_by_id(event_id).try(:lock!)
        event.send(:generate_changes)
      end
    end
  end

  # never call this method in production code, call lock_and_generate_changes instead
  # send to this method in test code
  def generate_changes(options = {})
    return if history_generated?
    self.update_attribute(:history_generated, true)

    do_generate_changes
    changes.reload
  end
  private :generate_changes

  def origin_description
    raise "subclass responsibility! #{self.class} should implement origin_description"
  end

  def source_type
    raise "subclass responsibility! #{self.class} should implement source_type"
  end

  def action_description
    creation? ? 'created' : 'changed'
  end

  def creation_category
    "creation"
  end

  def creation?
    if self.origin.respond_to?(:version)
      self.origin.version == 1
    end
  end

  def version_link
    nil
  end

  # author: whose action is result in this event.
  # author need be able to respond to name, email, and resource_link (sub set of User interface)
  def author
    created_by || NonMingleAuthor.new("Mingle System")
  end

  def snapshot
    raise "implemented by subclasses"
  end

  private

  def loading_time_threshold
    if override = ENV['EVENT_LOADING_TIME_THRESHOLD_MINUTES']
      override.to_i.minutes
    else
      Rails.env == "test" ? 10.seconds : 5.minutes
    end
  end
end
